// Copyright (c) 1993-2017 Robert McNeel & Associates. All rights reserved.
// Rhinoceros is a registered trademark of Robert McNeel & Associates.
//
// THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT EXPRESS OR IMPLIED WARRANTY.
// ALL IMPLIED WARRANTIES OF FITNESS FOR ANY PARTICULAR PURPOSE AND OF
// MERCHANTABILITY ARE HEREBY DISCLAIMED.
//				
// For complete Rhino SDK copyright information see <http://www.rhino3d.com/developer>.
//
////////////////////////////////////////////////////////////////
#pragma once

class RHINO_SDK_CLASS CUD_source_index : public ON_UserData
{
  ON_OBJECT_DECLARE(CUD_source_index);
public:
  CUD_source_index(int i = -1)
  {
    m_index = i;
    m_userdata_uuid = ON_CLASS_ID(CUD_source_index);
    m_userdata_copycount=1;
  };
  int m_index;
};


class RHINO_SDK_CLASS CRhinoUnroll
{
public:
  CRhinoUnroll(const ON_Surface* pSurface, double absolute_tol=0.01, double rel_tol=0.01 );
  CRhinoUnroll(const ON_Brep* pBrep, double absolute_tol=0.01, double rel_tol=0.01 );
  virtual ~CRhinoUnroll();

  //////////////////////////////////////////////////////
  // Step. 1 - See if brep can be unrolled
  // Description:
  //   See if the faces can be unrolled.  Find linear directions and connections to other faces
  //   Replace periodic and rational surfaces with clamped non-rational ones
  // Returns:
  //   -1: error
  //    0: only linear faces found
  //    1: non-linear faces found.
  int PrepareFaces(int direction_override = -1);

  //////////////////////////////////////////////////////
  // Step. 2 [optional] - Add extra geometry to follow unrolled surface
  // Split 3d curves and pull to individual surfaces and make curve on surface edges
  void PrepareCurves(const ON_SimpleArray<const ON_Curve*>& curves_on_surface);
  // Pull points to individual surfaces and make point on surface vertices
  void PreparePoints(const ON_SimpleArray<ON_3dPoint>& points_on_surface);
  // Pull points to individual surfaces and make point on surface vertices
  void PrepareDots(const ON_SimpleArray<const ON_TextDot*>& dots_on_surface);

  //void PrepareCurves(const ON_SimpleArray<const ON_Curve*>& curves_on_surface);
  //void PreparePoints(const ON_SimpleArray<ON_3dPoint>& points_on_surface);
  //void PrepareDots(const ON_SimpleArray<const ON_TextDot*>& dots_on_surface);

  //////////////////////////////////////////////////////
  // Step. 3
  // Flatten the surfaces, but no trims or breps are made
  bool FlattenFaces();

  //////////////////////////////////////////////////////
  // Step 4. If FlattenFaces returns success, call CreateFlatBreps
  // to transfer all trimming and "following" geometry to the flatted form
  // Transfer edges from 3d to 2d, including curves on srf and points on srf
  // Returns:
  //   number of breps generated by unrolling
  //   0 on error
  int CreateFlatBreps( bool explode, double explode_spacing=2.0);


  //////////////////////////////////////////////////////
  // Final Step. get all of the unrolled geometry
  // Get the flattened results from the unroller
  void CollectResults(ON_SimpleArray<ON_Brep*>& flatbreps,
                      ON_ClassArray<ON_SimpleArray<ON_Curve*> >& crvonsrf, 
                      ON_ClassArray<ON_SimpleArray<ON_3dPoint> >& ptonsrf, 
                      ON_ClassArray<ON_SimpleArray<ON_TextDot*> >& dotonsrf);


 
private:

#pragma region FaceLink
  //---------------------------------------------------------------------------
  class CFaceLink
  {
  public:
    CFaceLink();

    const class CRhinoUnroll* m_pUnroller;
    const ON_Brep* m_pBrep;  // pointer to a copy of the input
    int m_trim_index;
    int m_connected_trim_index;
    int m_facerec_index;
    int m_connected_facerec_index;
    bool m_bRev3d; // set true if the rev3d flags on mated trims differ
    bool m_bUsed;

    const ON_BrepTrim* FindTrim(int facerec_index, int trim_index);
    const ON_BrepTrim* Trim();
    const ON_BrepTrim* ConnectedTrim();
    const ON_BrepFace* Face();
    const ON_BrepFace* ConnectedFace();
  };

#pragma endregion

#pragma region FaceRec
  //---------------------------------------------------------------------------
  class CFaceRec
  {
  public: 
    CFaceRec();
    ~CFaceRec();

    enum eLinearDir
    {
      // linear_u means things going from v_min to v_max with constant u are linear
      // linear_v means things going from u_min to u_max with constant v are linear
      linear_none = 0,
      linear_u    = 1,     // East & West sides and verticals are linear
      linear_v    = 2,     // North & South sides and horizontals are linear
      linear_both = 3,
    };

    int SpanDivs();
    int GetSamplePoints();
    int GetPointsAndLengths(ON_NurbsSurface* pSrf, int dir);
    
    const ON_Brep*              m_pBrep;                   // pointer to a copy of the input that gets modified 
    int                         m_face_index;              // index in the brep - m_fi
    int                         m_linear_dir;              // which direction is flat
    ON_SimpleArray<CFaceLink>   m_links;                   // connections to other faces

    ON_Curve*                   m_rails[2];                // copies of isocurves from the input surface
    ON_NurbsCurve*              m_flatrails[2];            // flattened curves used to make new surface

    ON_SimpleArray<double>      m_input_sample_params;     // rail parameters of sample points
    ON_SimpleArray<ON_3dPoint>  m_sample_points[2];        // sample points from input rails
    ON_SimpleArray<double>      m_sample_lengths[2];       // lengths between consecutive sample points
    
    ON_SimpleArray<double>      m_flat_sample_params[2];   // corresponding parameters on flattened surface rails
    ON_SimpleArray<ON_3dPoint>  m_flat_sample_points[2];   // sample points on the flattened rails

    ON_Surface*                 m_pFlatSurface;            // flat ruled surface made from the re-fit rails

    double                      m_tolerance;               // model tolerance
    bool                        m_bUsed;
    double                      m_starting_area;
    double                      m_starting_rail_length[2];
    double                      m_ending_rail_length[2];

    bool                        m_bPlanar;                  // True if the starting face is planar
    ON_Xform                    m_planar_rotation;          // If the starting face is planar, this is the
                                                            // rotation to world xy plane

    // Results
    ON_SimpleArray<ON_Curve*>   m_flat_curves;
    ON_SimpleArray<ON_3dPoint>  m_flat_points;
    ON_SimpleArray<ON_TextDot*> m_flat_dots;
    ON_Brep*                    m_flat_brep;
  };
#pragma endregion

  double     m_reltol;
  double     m_abstol;
  int        FaceCount();
  bool       CreateFlatBrep(int i);
  int        CreateFlatBreps();
  bool       ExplodeFlattenedBreps(double hspacing);
  bool       ConnectFlattenedBreps();
  int        IsSrfLinear(const ON_Surface* pSrf, int dir, double relative_tol);
  int        FindSrfLinearDirection(ON_Surface* pSrf, int direction_override);
  bool       PullbackTrims(ON_Brep* pBrep, int face_index, double tolerance);
  void       MakeSrfNotRational(ON_NurbsSurface*& pNS, int linear_dir, double tolerance);
  int        ReplaceSpecialSurfaces(ON_Brep*& m_pBrep, ON_ClassArray<CFaceRec>& faces, double tolerance);
  bool       FlattenSumSrf(int i);
  bool       FlattenRevSrf(int i);
  bool       FlattenPlanarSrf(int i);
  bool       FlattenFace(int i, double tolerance);
  bool       PlotFlatRailPoints(CFaceRec& rec, double tolerance);
  bool       RuleFlattenedRails(CFaceRec& rec, double tolerance);
  bool       PullCurves();
  bool       FlattenDots();
  bool       FlattenPoints();
  int        CreateResultFaces();
  void       SetRailsAndLengths(int i);
  void       MakeFlatEdgeCurve(ON_BrepTrim* pT, int fi, ON_BrepFace& newface, ON_Curve** pEC, ON_Curve** pTC);
  ON_3dPoint ConvertFractionalDistances(int fi, ON_3dPoint& position);
  ON_3dPoint GetFractionalPosition(double u, double v, int fi, int linear_dir);
  bool       MakeFlatBoundaryLoop(int facerec_i, ON_BrepFace& newface, ON_Brep* pB, const ON_BrepLoop* pL);
  bool       MakeFlatCrvOnSrf(int facerec_i, ON_BrepFace& newface, const ON_BrepLoop* pL, ON_SimpleArray<ON_Curve*>& crvonsrf);
  bool       MakeFlatPtOnSrf(int face_i, ON_BrepFace& newface, const ON_BrepLoop* pL, ON_SimpleArray<ON_3dPoint>& ptonsrf, ON_SimpleArray<ON_TextDot*>& dotonsrf);
  void       ConnectFaceRec(int rec_index, int &depthstop);
  int        ConnectFaceLink(CFaceLink& link);
  int        ConvertPoints(ON_BrepTrim* pT, struct tagTL_POLYLINE* pl, int fi, int linear_dir, struct tagTL_POINTLIST*  plist);

  ON_Brep*                            m_pBrep;        // Copy of the input brep or brep with 
                                                      // one face from the input brep
  const ON_Brep*                      m_pInputBrep;   // pointer to the input
  const ON_Surface*                   m_pInputSurface;// pointer to the input
  bool                                m_bDeleteInputBrep;
  ON_ClassArray<CFaceRec>             m_faces;        // Linear faces in the input brep
                                                      // that are going to be flattened
private:
  ON__UINT_PTR m_sdk_reserved = 0;
};

class RHINO_SDK_CLASS RhDevelopableSurface
{
public:
  // For a ruling between two rails, rail0 and rail1, from rail0(t0) to rial1(t1),
  // the ruling twist is:
  // V = rail0(t1) - rail1(t0)
  // N0 = rail0.TangentAt(t0) cross V
  // N1 = rail1.TangentAt(t1) cross V
  // Twist = acos(N0 * N1)
  
  // Calc twist across one ruling
  static double CalcRulingTwist(
    const ON_Curve* rail0,
    const ON_Curve* rail1,
    double t0,
    double t1
  );

  // Find a ruling from rail0(t0) to rail1(t1_out) that has the least twist
  // across the ruling with t1_out in domain1.
  // max_cos_twist is cos(twist) for the returned ruling
  static bool FindMinTwist(
    const ON_Curve* rail0,
    const ON_Curve* rail1,
    double t0,               // param on rail0
    double t1,               // seed param on rail1
    ON_Interval domain1,     // search domain on rail1
    double& t1_out,          // best t on rail1
    double& max_cos_twist    // cos(twist) at rail0(t0_out), rail1(t1_out)
  );

  // Find a ruling from rail0(t0_out) to rail1(t1_out) that has the least twist
  // across the ruling with t0_out in domain0 and t1_out in domain1.
  // max_cos_twist is cos(twist) for the returned ruling
  static bool FindMinTwist(
    const ON_Curve* rail0,
    const ON_Curve* rail1,
    double t0,               // param on rail0
    double t1,               // param on rail1
    ON_Interval domain0,     // search domain on rail0
    ON_Interval domain1,     // search domain on rail1
    double& t0_out,          // best t on rail0
    double& t1_out,          // best t on rail1
    double& max_cos_twist    // twist at rail0(t0_out), rail1(t1_out)
  );

  static bool UntwistSurface(
    const ON_Curve* rail0,
    const ON_Curve* rail1,
    int rulingcount, 
    ON_2dPoint* rulings
  );

};


